%% CCD的计算
%干涉的角度确定，绕y轴转delta。alpha = 0；delta = 0.2mrad；
%CCD的微元面积为30e-6 X 30e-6；阵列为 320x256；
% 两道高斯光入射，入射参数相同，仅角度不同。
% 考虑频率差的影响
clear
clc
format long
delta = 0.1e-3;
f = 1623;% 频率差
T = 1/f;

w_0 = 2e-3;
lambda = 1064e-9;
k = 2*pi/lambda;
z_r = pi*1*w_0^2/lambda;

w = @(z) w_0*sqrt(1+(z/z_r).^2);
R_z = @(z) z./2./(z.^2+z_r^2);
phi_z = @(z) atan(z./z_r);
A = @(x,y,z) 1./w(z).*exp((-x.^2-y.^2)./w(z).^2);
Phi = @(x,y,z) k*((-x.^2-y.^2).*R_z(z)+z)-phi_z(z);

E_11 = @(x,y) A(x,y,0);
E_22 = @(x,y) A(x*cos(delta),y,x*sin(delta));
E_1 = @(x,y) E_11(x,y).*E_11(x,y);
E_2 = @(x,y) E_22(x,y).*E_22(x,y);

Phi_2 = @(x,y) Phi(x.*cos(delta),y,x.*sin(delta));

x = -160:159;
y = -128:127;
mu = 30e-6;
%%  计算60组数据
parfor t = 1:41
    t1 = T/40*t;
    E_3 = @(x,y) E_11(x,y).*E_22(x,y).*exp(-i*(Phi(x,y,0)-Phi(x*cos(delta),y,x*sin(delta))-2*pi*f*t1));
    I(:,:,t) = c(x,y,E_1,E_2,E_3,mu);
    t
end

%% 反演相位
format long
C = real(I);
for j = 1:length(x)
    for k = 1:length(y)
    p(j,k)=atan((I(j,k,41)-I(j,k,21))/(I(j,k,1)-I(j,k,11)));
    end
end
%%  消除相位跳变
A_1 = p;
for j = 1:256
     Q(j,:)=compent(A_1(j,:));
end
C = Q(:,1);
Q(:,1)=compent(C);
figure
plot(Q(:,1))
for j = 1:256
     Q(j,:)=compent(Q(j,:));
end
[r,v] = find(I(:,:,1) == max(max(I(:,:,1)))); 
W = Q(r,v);
Q = Q - min(W(:));
mesh(p)
hold on
mesh(Q)
%%
function T1 = c(x,y,E_1,E_2,E_3,mu)
for j = 1:length(x)
    for k = 1:length(y)
        xmin = x(j)*mu;
        xmax = (x(j)+1)*mu;
        ymin = y(k)*mu;
        ymax = (y(k)+1)*mu;
        I_1 = integral2(E_1,xmin,xmax,ymin,ymax,'Method','iterated');
        I_2 = integral2(E_2,xmin,xmax,ymin,ymax,'Method','iterated');
        I_3 = integral2(E_3,xmin,xmax,ymin,ymax,'Method','iterated');
        T1(j,k) = I_3+I_1+I_2;
    end
end
end

function T = compent(C)
% 输入一组行向量，数据存在跳变，输出的向量是以第一个元素为基准补偿所有跳变的分量得到的最终值
l = length(C);
delta = 0;%补偿相位差
delta1 = 0; %补偿平衡量
T(1) = C(1);
for j = 1:l-1
    chazhi = C(j+1)-C(j);
        if abs(chazhi)>=3
        if j == 1
            delta1 = C(4)-C(3);
%         elseif j==2
%             delta1 = C(4)-C(3);
        else
            delta1 = C(j)-C(j-1);
        end
        delta = delta+chazhi-delta1;
        end
    T(j+1) = C(j+1)-delta;
end
end